test project

https://github.com/PaoloFra/test

http://test.destyle.com.ua/

famework: Phalcon 2.0.13

Результат запроса
    SELECT ts.*, tr.ndc FROM `tb_source` ts
    LEFT JOIN `tb_rel` tr ON tr.cx=ts.cx
    WHERE ts.title LIKE 'title 1%'
представлен в трех вариантах таблиц (используя ORM, прямой SQL-запрос, ORM с кешированием данных 
в зависимости от сортировки и строки запроса) с сортировкой, разбивкой на страницы 
и произвольным поиском по началу поля 'title'.    
Для эффективного выполнения поисковых запросов проведена индексация таблиц базы (migrations/1.0.3/).
Поскольку размер результирующей выборки составляет внушительную величину (4167362 строк), 
пришлось увеличить требования PHP
memory_limit = 2048M
post_max_size = 128M
для обеспечения работоспособности в режимах SQL и ORM+кеш.
В то же время, выборка с помощью ORM справляется и при дефолтных настройках.
Кешированная выборка показывает несколько лучшие результаты при втором и далее обращениях, однако,
с ростом объема данных, эффективность такого решения становится сомнительной в первую очередь из-за объемов кеш-файлов, 
чтение которых становится все более времязатратным.
SQL-режим показывает наихудшие результаты из-за того, что выбранный механизм пагинации требует полного массива данных.
Средства встроенной ORM адаптированы к такому подходу, в отличии от прямого запроса. Это можно успешно решить,
написав свой вариант пагинации для SQL режима, только я решил, что это в задачу не входит.

Возможная оптимизация:
    Поскольку, по условиям, операции чтения очень преобладают над операциями записи, имеет смысл перейти 
    на тип таблиц MyISAM, это ускорит выборку данных. И, в расчете на переход на MyISAM, я не применял внешние ключи,
    пользуясь только механизмом связей и виртуальными внешними ключами ORM.

** в демо-версии http://test.destyle.com.ua/ все выборки ограничены LIMIT 10000 из-за слабых параметров виртуального хостинга.

Задача 2:

В таблицу tb_source добавлен первичный ключ id (migrations/1.0.3/).
Без этого подсчитать количество не представляется возможным.

SELECT COUNT(DISTINCT tt.id) FROM
(
    SELECT 
    ts.id
        -- , tr.ndc, COUNT(tr.ndc)  - just for the test
    FROM `tb_source` ts
    LEFT JOIN `tb_rel` tr ON tr.cx=ts.cx
        -- WHERE ts.id <=100000 - just for the test
    GROUP BY ts.id, tr.ndc
    HAVING COUNT(tr.ndc)>2
) tt;


